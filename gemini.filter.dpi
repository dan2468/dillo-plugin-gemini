#!/bin/bash
# dillo-gemini
# Â© 2020 cel @f/6sQ6d2CMxRUhLpspgGIulDxDCwYD7DzFzPNr7u5AU=.ed25519
# Copying and distribution of this file, with or without modification,
# are permitted in any medium without royalty provided the copyright
# notice and this notice are preserved.  This file is offered as-is,
# without any warranty.

read -d '>' auth
read -d '>' cmd
case "$cmd" in
	"<cmd='open_url' url='"*);;
	*) echo $cmd; exit;;
esac
url=${cmd#"<cmd='open_url' url='"}
url=${url%"' '"}

serve_404() {
	printf "<cmd='start_send_page' url='' '>\n"
	printf "Content-type: text/plain\r\n\r\n"
	echo Not found
}

render_gemini() {
	printf "Content-type: text/html\r\n\r\n"
	if which ansi2html 2>&1 >/dev/null
	then ansi2html
	else cat
	fi | awk '
		BEGIN {
			print "<!doctype html><body><style>"\
				"div { font:monospace; white-space:pre-wrap; }\n"\
				"h1, h2, h3 { margin: 0; }\n"\
				"</style>"
		}
		/^```/ {
			if (!in_literal) {
				in_literal = 1
				print "<pre>"
			} else {
				in_literal = 0
				print "</pre>"
			}
			next
		}
		in_literal {
			print
			next
		}
		in_list && !/^\*/ {
			in_list = 0
			print "</ul>"
		}
		/^\*/ {
			if (!in_list) {
				in_list = 1
				printf "<ul>"
			}
			match($0, /^\*+\s*/)
			text = substr($0, RLENGTH+1)
			printf "<li>%s</li>\n", text
			next
		}
		/^#+/ {
			match($0, /^#+/)
			tag = "h" RLENGTH
			match($0, /^(#+\s*)/)
			text = substr($0, RLENGTH+1)
			printf "<%s style=\"font:sans-serif\">%s</%s>\n", tag, text, tag
			next
		}
		/^=>/ {
			match($0, /^=>\s*/)
			href = substr($0, RLENGTH+1)
			if (match(href, /^\S+/)) {
				text = substr(href, RLENGTH+1)
				href = substr(href, 0, RLENGTH)
			}
			link = href
			sub(/:1965/, "", href)
			printf "<div><a href=\"%s\">%s</a>%s</div>\n", href, link, text
			next
		}
		/^$/ {
			print "<br>"
			next
		}
		{
			printf "<div>%s</div>\n", $0
		}
		END {
			print "</body>"
		}
	'
}

send_status_msg() {
	printf "<cmd='send_status_message' msg='%s' '>" "$*"
}

serve_status_not_supported() {
	printf "<cmd='start_send_page' url='' '>\n"
	printf "Content-type: text/plain\r\n\r\n"
	echo Status not implemented: $1
	echo $2
}

serve_missing_status() {
	printf "<cmd='start_send_page' url='' '>\n"
	printf "Content-type: text/plain\r\n\r\n"
	echo Empty status response. $2
}

serve_input() {
	printf "<cmd='start_send_page' url='' '>\n"
	prompt=$1
	# TODO: html-escape prompt
	printf "Content-type: text/html\r\n\r\n"
	cat <<-EOF
	<!doctype html>
	<html>
	<head>
	<title>Input</title>
	</head>
	<body>
	<form action="" method="get">
		<h3>$prompt</h3>
		<input name=_ style='width:100%'>
		<input type=submit>
	</form>
	</body>
	</html>
	EOF
}

serve_success() {
	printf "<cmd='start_send_page' url='' '>\n"
	type=$1
	case "$type" in
		text/gemini*) render_gemini;;
		*) printf "Content-type: $type\r\n\r\n"; cat;;
	esac
}

serve_redirect() {
	url=$1
	send_status_msg "Redirected"
	printf "<cmd='start_send_page' url='' '>\n"
	printf "Content-type: text/html\r\n\r\n"
	# TODO: html-escape url
	cat <<-EOF
	<!doctype html>
	<html>
	<head>
	<title>Redirect to $url</title>
	</head>
	<body>
	<h3>Redirect to <a href="$url">$url</a></3>
	</body>
	</html>
	EOF
}

serve_error() {
	status=$1
	meta=$2
	send_status_msg "Request failed"
	printf "<cmd='start_send_page' url='' '>\n"
	printf "Content-type: text/html\r\n\r\n"
	cat <<-EOF
	<!doctype html>
	<html>
	<head>
	<title>Request failed</title>
	</head>
	<body>
	<h3>Request failed: $status</h3>
	<code>$meta</code>
	</body>
	</html>
	EOF
}

serve_fail() {
	meta="$1"
	send_status_msg "Client certificate required"
	printf "<cmd='start_send_page' url='' '>\n"
	printf "Content-type: text/html\r\n\r\n"
	cat <<-EOF
	<!doctype html>
	<html>
	<head>
	<title>Client certificate required</title>
	</head>
	<body>
	<h3>Client certificate required</h3>
	<p>Not implemented!</p>
	<code>$meta</code>
	</body>
	</html>
	EOF
}

serve_gemini() {
	url=$1
	url1=${url#gemini://}
	hostname=${url1%%/*}
	host=${hostname%%:*}
	port=${hostname##*:}

	# replace "?_=" with "?".
	# dillo can only submit forms with name=value items, but Gemini
	# uses the whole querystring as a single string
	url1=${url%%?_=*}
	if [ "$url1" != "$url" ]; then
		url="${url1}?${url#*?_=}"
	fi

	if [ "$host" = "$port" ]; then port=1965; fi
	send_status_msg "Sending request..."
	printf "%s\r\n" "$url" | openssl s_client -verify_quiet -quiet "$host:$port" | {
		read status meta
		send_status_msg "Status: $status"
		meta=$(echo "$meta" | sed 's/\s*$//')
		case "$status" in
			1*) serve_input "$meta";;
			2*) serve_success "$meta";;
			3*) serve_redirect "$meta";;
			4*) serve_error "$status" "$meta";;
			5*) serve_error "$meta";;
			#6*) serve_client_cert_required "$meta";;
			'') serve_missing_status "$meta";;
			*) serve_status_not_supported "$status" "$meta";;
		esac
	}
}

case "$url" in
	gemini:*) serve_gemini "$url";;
	*) serve_404;;
esac
